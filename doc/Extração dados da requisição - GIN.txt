func SelectUser(c *gin.Context) {
	// Extrai o userID dos parâmetros da rota
	userID1 := c.Param("userID")

	// Converte userID para inteiro
	id1, convErr1 := strconv.Atoi(userID1)
	if convErr1 != nil {
		c.JSON(http.StatusBadRequest, gin.H{"mensagem": "userID inválido"})
		return
	}
	log.Printf("userID1 - Params=%v", userID1)

	// Extrai o userID da query string
	userID2 := c.Query("userID")
	if userID2 == "" {
		c.JSON(http.StatusBadRequest, gin.H{"mensagem": "userID não fornecido"})
		return
	}

	// Converte userID para inteiro
	id2, convErr2 := strconv.Atoi(userID2)
	if convErr2 != nil {
		c.JSON(http.StatusBadRequest, gin.H{"mensagem": "userID inválido"})
		return
	}
	log.Printf("userID2 - Query=%v - id2=%d", userID2, id2)

	// Define uma estrutura para capturar o corpo da requisição
	var requestData struct {
		UserID int `json:"userID"`
	}

	// Extrai os dados do corpo da requisição
	if err := c.ShouldBindJSON(&requestData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"mensagem": "Dados inválidos"})
		return
	}
	log.Printf("userID2 - Body=%v", requestData.UserID)
	// Usa o userID extraído no modelo para buscar os dados
	//users, err := usersModel.Services.SelectRow(requestData.UserID)
	users, err := usersModel.Services.SelectRow(id1)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"mensagem": "Erro ao listar usuário"})
		return
	}

	// Retorna os dados do usuário
	c.JSON(http.StatusOK, users)
}

Sim, há outras maneiras de extrair dados do corpo de uma requisição no Gin, sem usar `ShouldBindJSON`. Aqui estão algumas alternativas:

---

### 1. **`c.BindJSON`**
Semelhante a `ShouldBindJSON`, mas retorna um erro diretamente em vez de encerrar a execução automaticamente.

#### Exemplo:
```go
if err := c.BindJSON(&requestData); err != nil {
    c.JSON(http.StatusBadRequest, gin.H{"mensagem": "Dados inválidos"})
    return
}
```

- **Diferença:** `BindJSON` para a execução e retorna o erro diretamente, enquanto `ShouldBindJSON` é mais flexível em termos de como o erro é tratado.

---

### 2. **`c.Request.Body`**
Usar o corpo da requisição como um fluxo bruto e processá-lo manualmente.

#### Exemplo:
```go
body, err := io.ReadAll(c.Request.Body)
if err != nil {
    c.JSON(http.StatusBadRequest, gin.H{"mensagem": "Erro ao ler corpo da requisição"})
    return
}

if err := json.Unmarshal(body, &requestData); err != nil {
    c.JSON(http.StatusBadRequest, gin.H{"mensagem": "Dados inválidos"})
    return
}
```

- **Quando usar:** Se precisar manipular o corpo como texto ou binário antes de convertê-lo em JSON.

---

### 3. **`c.PostForm` ou `c.FormValue`**
Se os dados forem enviados como `application/x-www-form-urlencoded` em vez de JSON.

#### Exemplo:
```go
userID := c.PostForm("userID") // Obtém o campo userID enviado no corpo.
```

- **Quando usar:** Para formulários enviados com `application/x-www-form-urlencoded` ou `multipart/form-data`.

---

### 4. **Decodificação Manual com `json.Decoder`**
Você pode criar manualmente um decodificador para tratar erros ou stream de grandes dados.

#### Exemplo:
```go
decoder := json.NewDecoder(c.Request.Body)
if err := decoder.Decode(&requestData); err != nil {
    c.JSON(http.StatusBadRequest, gin.H{"mensagem": "Dados inválidos"})
    return
}
```

- **Vantagem:** Controle mais fino sobre como os dados são processados e decodificados.

---

### Qual Escolher?
- **`ShouldBindJSON` ou `BindJSON`:** Para a maioria dos casos com JSON.
- **`c.Request.Body`:** Se precisar de controle mais baixo ou processar o corpo bruto.
- **`c.PostForm`:** Quando os dados não são JSON, mas enviados via formulário.
- **`json.Decoder`:** Para manipulação avançada de streams ou decodificação personalizada.

Essas alternativas permitem mais controle sobre como o corpo da requisição é processado. O método ideal depende do formato e da necessidade de manipulação dos dados.
